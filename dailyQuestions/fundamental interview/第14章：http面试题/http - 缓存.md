关于缓存的介绍：
    什么是缓存？
    为什么需要缓存？
        性能优化，尽量减少网络请求的体积和数量；
        网络请求不稳定；
    哪些资源可以被缓存？
        静态资源（js css img）；
        webpack打包的是一个加了哈希值的静态js，重新打包后，哈希值变化，浏览器无法再命中缓存；

http缓存策略（强制缓存 + 协商缓存）：
    强制缓存：
        浏览器第一次请求，服务端返回资源和Cache-Control信息；
        Cache-Control：
            位于Response Headers中；
            控制强制缓存的逻辑；
            例如Cache-Control:max-age=31536000（单位是秒）；

        浏览器再次请求，先判断本地缓存资源是否过期：
            如果没有过期，直接使用本地资源；
            如果过期，重复第一次请求；

        Cache-Control的值：
            max-age：缓存时间；
            no-cache：不使用强制缓存；
            no-store：不使用强制缓存也不使用服务端的缓存措施；

            private：只允许最终用户执行缓存；
            public：允许中间路由和代理执行缓存；

        关于Expires：
            同在Response Headers中；
            同为控制缓存过期；
            已被Cache-Control代替；

    协商缓存：
        服务端缓存策略；
        服务端判断客户端资源，是否和服务端一样；
        一致则返回304，否则返回200和最新的资源；

        浏览器初次请求，服务端返回资源和资源标识；
        浏览器再次请求，请求中携带资源标识，服务端返回304或新的资源和新的资源标识；

        资源标识：
            在Response Headers中，有两种：
                Last-Modified/Last-Modified-Since：资源的最后修改时间；
                Etag/If-None-Match：资源的为一标识（一个字符串，类似人类的指纹）；

            优先使用Etag；
            Last-Modified只能精确到秒级；
            如果资源被重复生成，而内容不变，则Etag更精确；

刷新操作方式对缓存的影响：
    三种刷新操作：
        正常操作：地址栏输入url，跳转链接，前进后退等；
        手动刷新：F5，点击刷新按钮，右击菜单刷新；
        强制刷新：ctrl + F5；

    不同刷新操作，不同的缓存策略：
        正常操作：强制缓存有效，协商缓存有效；
        手动刷新：强制缓存失效，协商缓存有效；
        强制刷新：强制缓存失效，协商缓存失效；

小结：
    强制缓存：Cache-Control；
    协商缓存：Last-Modified/Etag，304状态码；
    完整的流程图；