链表：
    链表是一种物理结构（非逻辑结构），类似于数组；
    数组需要一段连续的内存空间，而链表是零散的；
    链表节点的数据结构：{value,next?,prev?}；

    零散的对象，通过指针来连接；

根据数组创建单向链表：
    思路：
        1，将数组末尾元素初始化为链表的tail；
        2，从数组的倒数第二个元素开始遍历，将遍历到的每个元素转化为链表的节点，并将其next指向前一个元素；

链表 vs 数组：
    都是有序结构；
    （对象、Set是无序结构）
    （对象和Map的根本区别在于是否有序）
    链表：查询慢O(n)，新增和删除快O(1)；
    数组：查询快O(1)，新增和删除慢O(n)；

    React Fiber使用了链表；

解题思路：
    反转，即节点next指向前一个节点；
    但这很容易造成nextNode的丢失；
    需要三个指针prevNode curNode nextNode； 

划重点：
    链表，链表 vs 数组；
    如何让nextNode不丢失；
    链表的代码逻辑比较繁琐，调试成本高；

连环问：链表和数组，哪个实现队列更快？
    分析：
        数组是连续存储，push很快，shift很慢；
        链表是非连续存储，add和delete都很很快（但查找很慢）；
    结论：链表实现队列更快；

    链表实现队列：
        单向链表，但要同时记录head和tail；
        要从tail入队，从head出队，否则出队时tail不好定位；
        length要实时记录，不可遍历链表获取；
      
    性能分析：
        空间复杂度都是O(n)；
        add时间复杂度：链表O(1)，数组O(1)；
        delete时间复杂度：链表O(1)，数组O(n)；

    划重点：
        链表，链表 vs 数组；
        数据结构的选择，要比算法优化更重要；
        要有时间复杂度的敏感性，如length不能遍历查找；



```js
const n1 = {
  value: 100,
  next: n2,
  prev: null
};
const n2 = {
  value: 200,
  next: n3,
  prev: n1
};
const n3 = {
  value: 300,
  next: n4,
  prev: n2
};
const n4 = {
  value: 400,
  next: null,
  prev: n3
};
```