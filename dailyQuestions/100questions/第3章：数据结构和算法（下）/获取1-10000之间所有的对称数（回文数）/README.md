求1-10000之间的所有对称数（回文）；
例如：0，1，2，11，22，101，232，1221；

思路1 - 使用数组反转、比较：
    数字转换为字符串，再转换为数组；
    数组reverse，再join为字符串；
    前后字符串进行对比；

    取一个字符串的反字符串：
  ```js
      s = str.split('').reverse().join('');
  ```

思路2 - 字符串头尾比较：
    数字转换为字符串；
    字符串头尾字符比较；
    （也可以用栈，像括号匹配，但要注意奇偶数）

思路3 - 生成翻转数：
    使用 % 和 Math.floor() 生成反转数；
    前后数字进行对比；
    （全程操作数字，没有字符串类型） 

    取一个数字的翻转数字：
  ```js
      while (n > 0) {
        rev = rev * 10 + (n % 10); // rev:3 --- 32 --- 321
        n = Math.floor(n / 10); // n:12 --- 1 --- 0
      }
  ```


性能分析：
    思路1 - 看似是O(n)，但数组转换、操作都需要时间，所以慢；
    思路2 vs 思路3，操作数字更快（电脑原型就是计算器）；
    思路2要用栈，不合适。因为栈也一般用数组实现，会慢；

划重点：
    尽量不要转换数据结构，尤其数组这种有序结构；
    尽量不要用内置API，如reverse，不好识别复杂度；
    数字操作最快，其次是字符串；