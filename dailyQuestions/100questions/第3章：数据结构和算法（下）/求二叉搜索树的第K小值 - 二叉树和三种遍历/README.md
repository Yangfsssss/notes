二叉树（Binary Tree）：
    是一棵树；
    每个节点，最多只能有2个子节点；
    树节点的数据结构{value,left?,right?}

二叉树的遍历：
    前序遍历：root --> left --> right；
    中序遍历：left --> root -->right；
    后序遍历：left --> right --> root；

二叉搜索树：
    left（包括其后代）value <= root value；
    right（包括其后代）value >= root value；
    可使用二分法进行快速查找；

解题思路：
    BST中序遍历，即从小到大排序；
    找到排序后的第k值即可；

划重点：
    二叉树，和三种（前序、中序、后序）遍历；
    二叉搜索树的特点：left <= root;right >= root;
    二叉搜索树的价值：可使用二分法进行快速查找；

为什么二叉树如此重要，而不是三叉树、四叉树？
    因为可以二分；

    注意事项：
        本节要“不求甚解”，掌握结果，不纠细节；
        你将体会到计算机科学的精妙与伟大；

    性能，性能，还是性能：
        数组：查找快O(1)，增删慢O(n)；
        链表：查找慢O(n)，增删快O(1)；
        二叉搜索树BST：查找快O(log n)，增删快 --- “木桶效应”；

    平衡二叉树：
        BST如果不平衡，那就成链表了；
        所以要尽量平衡：平衡二叉搜索树BBST；
        BBST增删查，时间复杂度都是O(log n)，即树的高度；
    
    红黑树：
        一种自平衡二叉树；
        分为红/黑两种颜色，通过颜色转换来维持树的平衡；
        相对于普通平衡二叉树，他维持平衡的效率更高；

    B树：
        物理上是多叉树，但逻辑上是二叉树；
        一般用于高效I/O，关系型数据库常用B树来组织数据；

    小结：
        数组、链表，各有各的缺点；
        特定的二叉树（BBST）可以让整体效果最优；
        各种高级二叉树，继续优化，满足不同场景；

堆有什么特点，和二叉树有什么关系？
    JS代码执行时：
    值类型数据，存储在栈；
    引用类型变量，存储在堆；

    堆：
        完全二叉树；
        最大堆：父节点 >= 子节点；
        最小堆：父节点 <= 子节点；
        满二叉树：左右填满；
        完全二叉树：左填满；

        逻辑结构 vs 物理结构：
            堆，逻辑结构是一颗二叉树；
            但它物理结构是一个数组（异化的二叉树）；
            数组：适合连续存储 + 节省空间（回顾堆栈模型）；
        
        堆的节点关系：
            parentIndex = Math.floor(index / 2);
            leftIndex = index * 2;
            rightIndex = index * 2 + 1;

        堆 vs BST：
            查询比BST慢；
            增删比BST快，维持平衡更快；
            但整体的时间复杂度都在O(log n)级别，即树的高度；

        堆的使用场景：
            特别适合“堆栈模型”；
            堆的形式，都是在栈中引用的，不需要从root遍历；
            堆恰巧是数组形式，根据栈的地址，可用O(1)找到目标；
        
        小结： 
            堆的模型，堆的场景；
            堆的特点，堆和BST；
            堆的逻辑结构和物理结构；



    



